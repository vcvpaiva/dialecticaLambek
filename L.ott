% Input variables.
metavar vars ,  x , y, z, w ::=  
indexvar ivar, i , k , j , l ::= 

grammar

A, B, C, D :: 'form_' ::=
  | I    ::   :: I
  {{tex I }}  
  | A (x) B :: :: Tensor
  {{tex [[A]] \otimes [[B]] }}  
  | A -> B :: :: RImp
  {{tex [[A]] \rightharpoonup [[B]] }}
  | A <- B :: :: LImp
  {{tex [[A]] \leftharpoonup [[B]] }}
  | ! A     ::   :: OfCourse
  {{tex ! [[A]] }}
  | E A     ::   :: Exchange
  {{tex \kappa [[A]] }}
  | ( A )   :: M :: Parens 
  | h( A )  :: M :: HiddenParens 
  {{ tex [[A]] }}

p :: 'pat_' ::=
  | punit :: :: UnitPatter
  {{tex \mathsf{unit} }}
  | - :: :: Hole
  | x :: :: Var
  | p1 (x) p2 :: :: Tensor
  {{tex [[p1]] \otimes [[p2]] }}

t :: 'term_' ::=
  | x                 :: :: Var
  | unit              :: :: Unit  
  {{tex \mathsf{unit} }}
  | appl t1 t2        :: :: Applicationl
  {{tex \mathsf{app}_l\,[[t1]]\,[[t2]] }}
  | appr t1 t2        :: :: Applicationr
  {{tex \mathsf{app}_r\,[[t1]]\,[[t2]] }}  
  | t1 (x) t2         :: :: Tensor
  {{tex [[t1]] \otimes [[t2]] }}
  | \l x : A . t      :: :: LambdaL
  {{tex \lambda_l [[x]]:[[A]].[[t]] }}
  | \r x : A . t      :: :: LambdaR
  {{tex \lambda_r [[x]]:[[A]].[[t]] }}  
  | let t1 be p in t2 :: :: Let
  {{tex \mathsf{let}\,[[t1]]\,\mathsf{be}\,[[p]]\,\mathsf{in}\,[[t2]] }}
  | { t }             :: S :: Parens
  {{tex ( [[t]] ) }}
  | [ t1 / x ] t2     :: M :: Sub
  | h( t )            :: M :: HiddenParens 
  {{ tex [[t]] }}
  
% Contexts:
G {{tex \Gamma}} :: 'G_' ::=
  | .           ::   :: Empty
  {{tex \cdot }}
  | A           ::   :: El
  | x : A       ::   :: TEl
  | G , G'      ::   :: Ext
  | ( G )       :: S :: Paren
  | !{ G }      :: M :: OfCourse
  {{tex ! [[G]] }}
  | E{ G }      :: M :: Exchange
  {{tex \kappa [[G]] }}  
  | h( G )      :: M :: HiddenParens 
  {{ tex [[G]] }}   
  
terminals :: '' ::=
  | (x)  ::  :: Tensor
  {{tex \otimes }}
  | 1    ::  :: One
  | 0    ::  :: Zero
  | []   :: :: Box  {{ tex \Box }}
  | |=   :: :: models  {{ tex \models }}
  | |-   :: :: Turnstyle  {{tex \vdash }}
  | star :: :: star   {{ tex \mathop{\star} }}
  | >>   :: :: RR   {{ tex \gg}}
  | _    :: :: Under   {{tex \Box}}
  | \    :: :: slash  {{ tex \lambda }}
  | ~>   :: :: step  {{ tex \redto }}
  | ~*>   :: :: sstep  {{ tex \redto^* }}
  | >=   :: :: succeq {{ tex \succeq }}
  | <=   :: :: preceq {{ tex \preceq }}
  | ->   :: :: rightarrow  {{ tex \rightarrow }}
  | <-   :: :: leftarrow  {{ tex \leftarrow }}
  | -<   :: :: Yleft  {{ tex \Yleft }}
  | ~*>  :: :: mstep  {{ tex \redto^* }}
  | =    :: :: Eq
  | ==   :: :: Equiv  {{ tex \equiv }}
  | =~   :: :: Cong  {{ tex \cong }}
  | bot  :: :: Bottom   {{ tex \mathop{\perp} }}
  | top  :: :: Top   {{ tex \top }}
  | *    :: :: Cut  {{ tex \bullet}}
  | ~    :: :: Tilde  {{tex \mathop{\sim} }}
  | \    :: :: Lam {{ tex \lambda }}
  | mu   :: :: Mu {{ tex \mu }}
  | !=   :: :: Neq {{tex \neq }}
  | FV   :: :: FV  {{ tex \mathsf{FV} }}
  | in   :: :: In {{ tex \in }}

 formula :: 'formula_' ::=
  | judgement               ::  :: judgement
  | formula <= formula'     :: M :: PJ
  | ( formula )             :: M :: ParenF
  | formula && formula'     ::  :: judgement_list 
  {{ tex [[formula]] \qquad [[formula']] }}
  | ( formula )             ::  :: parens
  | x nin FV( t )           ::  :: FV
  {{tex [[x]] \not\in \mathsf{FV}([[t]]) }}

defns
  Jtyp :: '' ::=

defn
 G |- A :: :: Log :: '' 
 {{tex [[G]] \vdash [[A]] }}
 by

 ------ :: ax
 A |- A

 ------ :: Ur
 . |- I

 G2 |- A && G1,A,G3 |- B
 ----------------------- :: cut
 G1,G2,G3 |- B

 G1,G2 |- A
 ------------ :: Ul
 G1,I,G2 |- A

 G,A,B,G' |- C
 ------------------ :: Tl
 G, A (x) B,G' |- C

 G1 |- A && G2 |- B
 ------------------ :: Tr
 G1,G2 |- A (x) B

 G2 |- A && G1, B , G3 |- C
 -------------------------- :: IRl
 G1,A -> B,G2,G3 |- C

 G2 |- A && G1,B,G3 |- C
 ----------------------- :: ILl
 G1,G2,B <- A,G3 |- C

 G, A |- B
 ----------- :: IRr
 G |- A -> B

 A, G |- B
 ----------- :: ILr
 G |- B <- A

 G, !A, !A |- B
 ----------------- :: C
 G, !A |- B

 G |- B
 ---------- :: W
 G, !A |- B

 !{G} |- B
 -------- :: Br
 !{G} |- !B

 G, A |- B
 ---------- :: Bl
 G, !A |- B

 E{G} |- B
 ----------- :: Er
 E{G} |- E B

 G, A |- B
 ---------- :: El
 G, E A |- B

 G, E A , B |- C
 --------------- :: E1
 G, B , E A |- C

 G, A , E B |- C
 --------------- :: E2
 G, E B , A |- C

defn
 G |- t : A :: :: JType :: 'T_' 
 {{tex [[G]] \vdash [[t]] : [[A]] }}
 by

 -------------- :: var
 x : A |- x : A

 -------------- :: Ur
 . |- unit : I

 G2 |- t1 : A && G1,x : A,G3 |- t2 : B
 ---------------------------------- :: cut
 G1,G2,G3 |- [t1/x]t2 : B

 G1,G2 |- t : A
 --------------------------------------- :: Ul
 G1, x : I,G2 |- let x be punit in t : A

 G,x : A,y : B,G' |- t : C
 ---------------------------------------------- :: Tl
 G, z : A (x) B,G' |- let z be x (x) y in t : C

 G1 |- t1 : A && G2 |- t2 : B
 ------------------------------- :: Tr
 G1,G2 |- h(t1 (x) t2) : h(A (x) B)

 G2 |- t1 : A && G1, x : B,G3 |- t2 : C
 ------------------------------------------ :: IRl
 G1,z : A -> B,G2,G3 |- [appr z t1/x]t2 : C

 G2 |- t1 : A && G1,x : B,G3 |- t2 : C
 ------------------------------------------ :: ILl
 G1,G2,z : B <- A,G3 |- [appl z t1/x]t2 : C

 G, x : A |- t : B
 ---------------------- :: IRr
 G |- \r x:A.t : A -> B

 x : A, G |- t : B
 ---------------------- :: ILr
 G |- \l x:A.t : B <- A

defn
 t1 ~> t2 :: :: ReW :: 'R_' 
 {{tex [[t1]] \rightsquigarrow [[t2]] }}
 by

 y nin FV(t)
 ----------- :: Alpha
 [y/x]t ~> t

 --------------------- :: Etal
 t ~> \l x:A.appl t x

 -------------------- :: Etar
 t ~> \r x:A.appr t x 

 ------------------------------- :: Betal
 appl {\l x:A.t2} t1 ~> [t1/x]t2

 ------------------------------- :: Betar
 appr {\r x:A.t2} t1 ~> [t1/x]t2

 ----------------------------------------- :: BetaU
 let t1 be punit in [unit/z]t2 ~> [t1/z]t2

 ------------------------------------------------ :: BetaT1
 let t1 (x) t2 be x (x) y in t ~> [t1/x][t2/y]t

 ---------------------------------------------- :: BetaT2
 let t1 be x (x) y in [x (x) y/z]t2 ~> [t1/x]t2

 -------------------------------------------------------------- :: NatU
 [let t1 be punit in t2/z]t3 ~> let t1 be punit in [t2/z]t3

 -------------------------------------------------------------- :: NatT
 [let t1 be x (x) y in t2/z]t3 ~> let t1 be x (x) y in [t2/z]t3

 --------------------------- :: LetU
 let unit be punit in t ~> t

 t1 ~> t2
 ------------------------------------ :: Let
 let x be p in t1 ~> let x be p in t2

 t1 ~> t1'
 ----------------------- :: T1
 t1 (x) t2 ~> t1' (x) t2

 t2 ~> t2'
 ----------------------- :: T2
 t1 (x) t2 ~> t1 (x) t2'

 t1 ~> t1'
 ------------------------- :: Al1
 appl t1 t2 ~> appl t1' t2

 t2 ~> t2'
 ------------------------ :: Al2
 appl t1 t2 ~> appl t1 t2'

 t1 ~> t1'
 ------------------------- :: Ar1
 appr t1 t2 ~> appr t1' t2

 t2 ~> t2'
 ------------------------ :: Ar2
 appr t1 t2 ~> appr t1 t2'

 t ~> t'
 --------------------- :: Ll
 \l x:A.t ~> \l x:A.t'

 t ~> t'
 --------------------- :: Lr
 \r x:A.t ~> \r x:A.t'