% Input variables.
metavar vars ,  x , y, z, w ::=  
indexvar ivar, i , j , l ::= 

grammar

A, B, C, D :: 'form_' ::=
  | I    ::   :: I
  {{tex I }}  
  | A (x) B :: :: Tensor
  {{tex [[A]] \otimes [[B]] }}  
  | A -> B :: :: RImp
  {{tex [[A]] \rightharpoonup [[B]] }}
  | A <- B :: :: LImp
  {{tex [[A]] \leftharpoonup [[B]] }}
  | ! A     ::   :: OfCourse
  {{tex ! [[A]] }}
  | E A     ::   :: Exchange
  {{tex \kappa [[A]] }}
  | ( A )   :: M :: Parens 
  | h( A )  :: M :: HiddenParens 
  {{ tex [[A]] }}

p :: 'pat_' ::=
  | punit :: :: UnitPatter
  {{tex \mathsf{unit} }}
  | h :: :: Hole
  {{tex - }}
  | x :: :: Var
  | p1 (x) p2 :: :: Tensor
  {{tex [[p1]] \otimes [[p2]] }}

t :: 'term_' ::=
  | x                 :: :: Var
  | unit              :: :: Unit  
  {{tex \mathsf{unit} }}
  | appl t1 t2        :: :: Applicationl
  {{tex \mathsf{app}_l\,[[t1]]\,[[t2]] }}
  | appr t1 t2        :: :: Applicationr
  {{tex \mathsf{app}_r\,[[t1]]\,[[t2]] }}  
  | t1 (x) t2         :: :: Tensor
  {{tex [[t1]] \otimes [[t2]] }}
  | \l x : A . t      :: :: LambdaL
  {{tex \lambda_l [[x]]:[[A]].[[t]] }}
  | \r x : A . t      :: :: LambdaR
  {{tex \lambda_r [[x]]:[[A]].[[t]] }}  
  | let t1 be p in t2 :: :: Let
  {{tex \mathsf{let}\,[[t1]]\,\mathsf{be}\,[[p]]\,\mathsf{in}\,[[t2]] }}
  | copy t' as t1 , t2 in t :: :: Copy
  {{tex \mathsf{copy}\,[[t']]\,\mathsf{as}\,[[t1]],[[t2]]\,\mathsf{in}\,[[t]] }}
  | discard t' in t :: :: Discard
  {{tex \mathsf{discard}\,[[t']]\,\mathsf{in}\,[[t]] }}
  | discard t' in t :: :: DiscardVec
  {{tex \mathsf{discard}\,[[t']]\,\mathsf{in}\,[[t]] }}  
  | promote! t' for ! y in t :: :: Promote
  {{tex \mathsf{promote}_!\,[[t']]\,\mathsf{for}\,\vec{[[y]]}\,\mathsf{in}\,[[t]] }}
  | derelict! t :: :: Derel
  {{tex \mathsf{derelict}_!\,[[t]] }}
  | promoteE E x for E y in t :: :: Promotek
  {{tex \mathsf{promote}_\kappa\,\vec{[[x]]}\,\mathsf{for}\,\vec{[[y]]}\,\mathsf{in}\,[[t]] }}
  | derelictE t :: :: Derelk
  {{tex \mathsf{derelict}_\kappa\,[[t]] }}
  | rexchange x with y in t :: :: REx
  {{tex \mathsf{exchange_r}\,[[x]]\,\mathsf{with}\,[[y]]\,\mathsf{in}\,[[t]] }}
  | lexchange x with y in t :: :: LEx
  {{tex \mathsf{exchange_l}\,[[x]]\,\mathsf{with}\,[[y]]\,\mathsf{in}\,[[t]] }}
  | ! t               :: M :: BTerm
  {{tex \vec{[[t]]} }}
  | { t }             :: S :: Parens
  {{tex ( [[t]] ) }}
  | [ t1 / t ] t2     :: M :: Sub
  | h( t )            :: M :: HiddenParens 
  {{ tex [[t]] }}
  
% Contexts:
G {{tex \Gamma}} :: 'G_' ::=
  | .           ::   :: Empty
  {{tex \cdot }}
  | A           ::   :: El
  | x : A       ::   :: TEl
  | G , G'      ::   :: Ext
  | ! x : !{ G } :: M :: Vec
  {{tex \vec{[[x]]} : ![[G]] }}
  | E x : E{ G } :: M :: Veck
  {{tex \vec{[[x]]} : \kappa [[G]] }}  
  | ( G )       :: S :: Paren
  | !{ G }      :: M :: OfCourse
  {{tex ! [[G]] }}
  | E{ G }      :: M :: Exchange
  {{tex \kappa [[G]] }}  
  | h( G )      :: M :: HiddenParens 
  {{ tex [[G]] }}   
  
terminals :: '' ::=
  | (x)  ::  :: Tensor
  {{tex \otimes }}
  | 1    ::  :: One
  | 0    ::  :: Zero
  | []   :: :: Box  {{ tex \Box }}
  | |=   :: :: models  {{ tex \models }}
  | |-   :: :: Turnstyle  {{tex \vdash }}
  | star :: :: star   {{ tex \mathop{\star} }}
  | >>   :: :: RR   {{ tex \gg}}
  | _    :: :: Under   {{tex \Box}}
  | \    :: :: slash  {{ tex \lambda }}
  | ~>   :: :: step  {{ tex \redto }}
  | ~*>   :: :: sstep  {{ tex \redto^* }}
  | >=   :: :: succeq {{ tex \succeq }}
  | <=   :: :: preceq {{ tex \preceq }}
  | ->   :: :: rightarrow  {{ tex \rightarrow }}
  | <-   :: :: leftarrow  {{ tex \leftarrow }}
  | -<   :: :: Yleft  {{ tex \Yleft }}
  | ~*>  :: :: mstep  {{ tex \redto^* }}
  | =    :: :: Eq
  | ==   :: :: Equiv  {{ tex \equiv }}
  | =~   :: :: Cong  {{ tex \cong }}
  | bot  :: :: Bottom   {{ tex \mathop{\perp} }}
  | top  :: :: Top   {{ tex \top }}
  | *    :: :: Cut  {{ tex \bullet}}
  | ~    :: :: Tilde  {{tex \mathop{\sim} }}
  | \    :: :: Lam {{ tex \lambda }}
  | mu   :: :: Mu {{ tex \mu }}
  | !=   :: :: Neq {{tex \neq }}
  | FV   :: :: FV  {{ tex \mathsf{FV} }}
  | in   :: :: In {{ tex \in }}

 formula :: 'formula_' ::=
  | judgement               ::  :: judgement
  | formula <= formula'     :: M :: PJ
  | ( formula )             :: M :: ParenF
  | formula && formula'     ::  :: judgement_list 
  {{ tex [[formula]] \qquad [[formula']] }}
  | ( formula )             ::  :: parens
  | x nin FV( t )           ::  :: FV
  {{tex [[x]] \not\in \mathsf{FV}([[t]]) }}

defns
  Jtyp :: '' ::=

defn
 G |- A :: :: Log :: '' 
 {{tex [[G]] \vdash [[A]] }}
 by

 ------ :: ax
 A |- A

 ------ :: Ur
 . |- I

 G2 |- A && G1,A,G3 |- B
 ----------------------- :: cut
 G1,G2,G3 |- B

 G1,G2 |- A
 ------------ :: Ul
 G1,I,G2 |- A

 G,A,B,G' |- C
 ------------------ :: Tl
 G, A (x) B,G' |- C

 G1 |- A && G2 |- B
 ------------------ :: Tr
 G1,G2 |- A (x) B

 G2 |- A && G1, B , G3 |- C
 -------------------------- :: IRl
 G1,A -> B,G2,G3 |- C

 G2 |- A && G1,B,G3 |- C
 ----------------------- :: ILl
 G1,G2,B <- A,G3 |- C

 G, A |- B
 ----------- :: IRr
 G |- A -> B

 A, G |- B
 ----------- :: ILr
 G |- B <- A

 % Had to generalize to three contexts in the following rule in order
 % for the promotion vs contraction case of cut elimination to go
 % through.
 G1, !A, G2, !A,G3 |- B
 ---------------------- :: C
 G1, !A, G2,G3 |- B

 G1,G2 |- B
 ------------- :: W
 G1,!A,G2 |- B

 !{G} |- B
 -------- :: Br
 !{G} |- !B

 G1, A, G2 |- B
 --------------- :: Bl
 G, !A, G2 |- B

 E{G} |- B
 ----------- :: Er
 E{G} |- E B

 G1, A, G2 |- B
 ---------------- :: El
 G1, E A, G2 |- B

 G1, E A , B,G2 |- C
 ------------------- :: E1
 G1, B , E A,G2 |- C

 G1, A , E B,G2 |- C
 --------------- :: E2
 G1, E B , A,G2 |- C

defn
 G |- t : A :: :: JType :: 'T_' 
 {{tex [[G]] \vdash [[t]] : [[A]] }}
 by

 -------------- :: var
 x : A |- x : A

 -------------- :: Ur
 . |- unit : I

 G2 |- t1 : A && G1,x : A,G3 |- t2 : B
 ---------------------------------- :: cut
 G1,G2,G3 |- [t1/x]t2 : B

 G1,G2 |- t : A
 --------------------------------------- :: Ul
 G1, x : I,G2 |- let x be punit in t : A

 G,x : A,y : B,G' |- t : C
 ---------------------------------------------- :: Tl
 G, z : A (x) B,G' |- let z be x (x) y in t : C

 G1 |- t1 : A && G2 |- t2 : B
 ------------------------------- :: Tr
 G1,G2 |- h(t1 (x) t2) : h(A (x) B)

 G2 |- t1 : A && G1, x : B,G3 |- t2 : C
 ------------------------------------------ :: IRl
 G1,z : A -> B,G2,G3 |- [appr z t1/x]t2 : C

 G2 |- t1 : A && G1,x : B,G3 |- t2 : C
 ------------------------------------------ :: ILl
 G1,G2,z : B <- A,G3 |- [appl z t1/x]t2 : C

 G, x : A |- t : B
 ---------------------- :: IRr
 G |- \r x:A.t : A -> B

 x : A, G |- t : B
 ---------------------- :: ILr
 G |- \l x:A.t : B <- A

 G1, x : !A, G2,y : !A, G3 |- t : B
 -------------------------------------------- :: C
 G1, z : !A, G2,G3 |- copy z as x, y in t : B

 G1, G2 |- t : B
 ------------------------------------ :: W
 G1, x : !A, G2 |- discard x in t : B

 !x : !{G} |- t : B
 ----------------------------------------- :: Br
 !y : !{G} |- promote! !y for !x in t : !B

 G1, x : A, G2 |- t : B
 -------------------------------------- :: Bl
 G1, y : !A, G2 |- [derelict! y/x]t : B

 E x : E{G} |- t : B
 --------------------------------------------- :: Er
 E y : E{G} |- promoteE E y for E x in t : E B

 G1, x : A,G2 |- t : B
 -------------------------------------- :: El
 G1, y : E A,G2 |- [derelictE y/x]t : B

 G1, x : E A , y : B,G2 |- t : C
 ----------------------------------------------------- :: E1
 G1, y : B , x : E A,G2 |- lexchange x with y in t : C

 G1, x : A , y : E B,G2 |- t : C
 ----------------------------------------------------- :: E2
 G1, y : E B , x : A,G2 |- rexchange x with y in t : C

defn
 t1 ~> t2 :: :: ReW :: 'R_' 
 {{tex [[t1]] \rightsquigarrow [[t2]] }}
 by

 y nin FV(t)
 ----------- :: Alpha
 [y/x]t ~> t

 --------------------- :: Etal
 t ~> \l x:A.appl t x

 -------------------- :: Etar
 t ~> \r x:A.appr t x 

 ------------------------------- :: Betal
 appl {\l x:A.t2} t1 ~> [t1/x]t2

 ------------------------------- :: Betar
 appr {\r x:A.t2} t1 ~> [t1/x]t2

 ----------------------------------------- :: BetaU
 let t1 be punit in [unit/z]t2 ~> [t1/z]t2

 ------------------------------------------------ :: BetaT1
 let t1 (x) t2 be x (x) y in t ~> [t1/x][t2/y]t

 ---------------------------------------------- :: BetaT2
 let t1 be x (x) y in [x (x) y/z]t2 ~> [t1/x]t2

 -------------------------------------------------------------- :: NatU
 [let t1 be punit in t2/z]t3 ~> let t1 be punit in [t2/z]t3

 -------------------------------------------------------------- :: NatT
 [let t1 be x (x) y in t2/z]t3 ~> let t1 be x (x) y in [t2/z]t3

 --------------------------- :: LetU
 let unit be punit in t ~> t

 ------------------------------------------------- :: BetaDR
 derelict! {promote! !t for !x in t1} ~> [!t/!x]t1

 ------------------------------------------------------------ :: BetaDI
 discard {promote! !t for !x in t1} in t2 ~> discard !t in t2

 ------------------------------------------------------------------------------------------------------------------------------ :: BetaC
 copy {promote! !t for !x in t1} as w,z in t2 ~> copy !t as !w,!z in [promote! !w for !x in t1/w][promote! !z for !x in t1/z]t2

 ---------------------------------------------- :: NatD
 [discard t in t1/x]t2 ~> discard t in [t1/x]t2

 ------------------------------------------------------ :: NatC
 [copy t as x,y in t1/x]t2 ~> copy t as x,y in [t1/x]t2

 t1 ~> t2
 ------------------------------------ :: Let
 let x be p in t1 ~> let x be p in t2

 t1 ~> t1'
 ----------------------- :: T1
 t1 (x) t2 ~> t1' (x) t2

 t2 ~> t2'
 ----------------------- :: T2
 t1 (x) t2 ~> t1 (x) t2'

 t1 ~> t1'
 ------------------------- :: Al1
 appl t1 t2 ~> appl t1' t2

 t2 ~> t2'
 ------------------------ :: Al2
 appl t1 t2 ~> appl t1 t2'

 t1 ~> t1'
 ------------------------- :: Ar1
 appr t1 t2 ~> appr t1' t2

 t2 ~> t2'
 ------------------------ :: Ar2
 appr t1 t2 ~> appr t1 t2'

 t ~> t'
 --------------------- :: Ll
 \l x:A.t ~> \l x:A.t'

 t ~> t'
 --------------------- :: Lr
 \r x:A.t ~> \r x:A.t'